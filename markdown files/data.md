# Объекты

Объекты передаются по ссылке, а не по значению, например:

```javascript
var value = {};
value.name = 'vasya';
var message = value;
message.name = 'petya';

console.log(value); // petya
console.log(message); // petya
```

### Перебор всех свойств в объекте

Для перебора всех свойств в объекте используют конструкцию `for..in`:

```javascript
for (var key in object) {
     // тело цикла     
     // где key - имя свойства, а object[key] - значение
}
```

Чтобы посчитать сколько свойство хранит объект можно воспользоваться двумя способами:

**Способ 1**
```javascript
var counter = 0;
for (var key in obj) {
     counter++;
}
```

**Способ 2**
```javascript
var counter = Object.keys(object).length;
```

По стандарту: если имя свойства нечисловая строка, то такие свойства перебираются в порядке присвоения.

### Удаление свойства
Удаление свойства происходит по ему ключу: `delete obj.name`

### Проверка свойства на существование

Проверка свойства на существование осуществляется с помощью оператора `if ('prop' in obj)` или `if (obj.prop !== undefined)`

# Псевдомассив arguments

Любая функция может быть вызвана с любым количеством аргументом - ошибки при этом не будет:

```javascript
function go(a,b) {
  alert("a="+a+", b="+b);
}
go(1);     // a=1, b=undefined
go(1,2);   // a=1, b=2
go(1,2,3); // a=1, b=2, третий аргумент не вызовет ошибку
```
Доступ к лишним аргументам осуществляется с помощью псевдомассива `arguments` - он содержит все аргументы функции под номерами arguments[0], arguments[1], arguments[n], а так же свойство length.

### Связь параметров функции и arguments

В старом стандарте была связь между параметрами функции, с которыми она была вызвана и псевдомассивом arguments:

```javascript
function f(x) {
  arguments[0] = 5; // меняет переменную x
  alert( x ); // 5
}

f(1);
```

а так же наоборот:

```javascript
function f(x) {
  x = 5;
  alert( arguments[0] ); // 5, обновленный x
}

f(1);
```

В современной редакции стандарта (в строгом режиме) это поведение изменено и аргументы отвязаны от arguments.

`Arguments` - это не массив, а объект с числовыми ключами. Он не имеет методов массива. Но можно из него скопировать с помощью цикла `for` все значения в обычный массив и уже у него вызывать методы массива.

**(!)** Если функция вызвана с меньшим количеством аргументов, чем указано при ее определении, то недостающие аргументы будут равны `undefined`.

# Строки

### Свойства и методы для работы со строками:

- str.length - указывает длину строки, может применяться как `console.log('Вася'.length); // 4`
- str.charAt(n) - возвращает указанный символ строки в виде строки, например:
```javascript
var str = 'string';
var char2 = str.chatAt(2);// 'r'
```
Такой же результат можно было получить с помощью вызова `var char2 = str[2];`. Разница между способами заключается в том, что если символа нет, charAt вернет пустую строку `''`, а str[n] - вернет `undefined`.
- str.toLowerCase() и str.toUpperCase() - меняют регистр строки на нижний/верхний.
- str.indexOf() - возвращает позицию найденной подстроки, или `-1`, если она не найдена. Необязательный второй аргумент позволяет искать с заданной позиции. Например:
```javascript
var str = 'gstring';
var result1 = str.indexOf('s'); // 0
var result2 = str.indexOf('s'); // 6
var result3 = str.indexOf('f'); // -1
```
Также существует аналогичный метод lastIndexOf, который ищет не с начала, а с конца строки.

# Массивы

### Общее

Согласно спецификации, массивы являются объектами, в которые добавили ряд свойств, методов и длину length. Предназначены для работы именно с непрерывной упорядоченной коллекцией.

Современные интерпретаторы стараются оптимизировать работу с массивами. Необходимо заполнять массив непрерывно и по возрастающей - в этом случае интерпретатор будет работать с массивом как с массивом, а если установить значения в массив `arr[5] = 5`, а затем сразу `arr[1000] = 1000`, то тогда интерпретатор будет работать с массивом как с объектом. По этой же причине, массиву не стоит ставить произвольные свойства, например, `arr.test = 5`. Так же, операции с массивами оптимизируются, если массив хранит только один тип данных - например, только числа.

### Создание массива

Синтаксис для создания массива:

- `var arr = [];`
- `var arr = new Array();`

При создании массива через new Array() в параметрах можно указать значения, которые станут элементами массива. Но есть одна особенность: если параметром new Array будет одно числовое значение, то будет создан массив с пустыми элементами (все будут равны undefined) с длинной, равной переданному значению при вызове.

Запись `[]` короче и нужно использовать именно ее.

### Длинна массива `length`

** Длинна массива **- это не количество его элементов, а последний индекс + 1. Например:
```javascript
var arr = [];
arr[1000] = 5;
console.log(arr.length;) // 1001
```

Есть одна особенность - массив можно укоротить с помощью свойства length. Например:

```javascript
var arr = [1, 2, 3, 4, 5];
arr.length = 2;
console.log(arr); // 1, 2 - элементы удалились навсегда
arr.length = 5;
console.log(arr); // 1, 2 - элементы не вернулись
```
С помощью этого способа можно быстро очистить массив, установив значение длинны массива в 0: `arr.length = 0;`

### Методы для изменения с массивом

- **push** - метод добавляет элемент в конец массива.

- **pop** - метод удаляет последний элемент массива и возвращает его.

- **unshift** - метод добавляет элемент массива в начало.

- **shift** - метод удаляет первый элемент массива и возвращает его.

Методы `push` и `pop` работают быстрее, чем `unshift` и `shift`. Потому что при работе с последним элементом он просто удаляется из конца массива, а значение длинны `length` уменьшается на единицу. Тогда как при работе с первым элементом, все элементы массива еще и сдвигаются на одно значение вперед или назад.

### Методы для работы с массивом

- **reverse** - метод меняет порядок элементов в массиве на обратный.

- **concat** - метод копирует часть массива в новый массив, не изменяя исходный.

- **indexOf** - метод осуществляет поиск элементов в массиве. Возвращает позицию найденного элемента или, если элемент не найден, то `-1`.

- **lastIndexOf** - метод аналогичен методу indexOf, за исключением того, что осуществляет поиск с конца массива (справа-налево).

- **sort** - метод возвращает новый отсортированный массив, не изменяя исходный.

- **split** - метод разбивает строку по разделителю и создает из них массив.

- **join** - метод склеивает в строку все элементы массива по разделителю.

- **splice** - метод заменяет и/или удаляет элементы из массива и возвращает массив из удаленных элементов.

- **Object.keys()** - метод возвращает массив из собственных перечисляемых свойств объекта в том же порядке, в котором они бы обходились циклом `for..in`. Синтаксис:
```javascript
var obj = {
	name: 'Vasya',
	age: 22
};
var keysArray = Object.keys(obj);
console.log(keysArray); // [name, age]
```

### Перебирающие массив методы

- **forEach** - метод перебирает массив и для каждого элемента вызывает функцию callback, в которую передает три элемента: текущий элемент, его индекс и сам перебираемый массив. Метод ничего не возвращает, а является элегантной заменой циклу `for`. Синтаксис:
```javascript
arr.forEach(function(item, i, arr) {
	console.log('Элемент ' + item + ' на позиции ' + i);
});
```
Метод можно использовать, если необходимо произвести действия с каждым элементом. Если же необходимо прервать цикл на определенном элементе, то лучше использовать обычный цикл `for`, потому как метод не имеет механизма прерывания, например, как `break` в цикле `for`. Так же, можно написать вот так:
```javascript
var index;
arr.forEach(function(item, i, arr) {
	if (item === 'cat') {
		index = i;
	}
});
```

- **map** - метод используется для трансформации массива и возвращает новый массив, который будет состоять из результатов вызова функции callback для каждого элемента исходного массива.
```javascript
var arr = [1, 2, 3, 4, 5];
var doubleArray = arr.map(function(value) {
	return value * 2;
});
console.log(doubleArray); // [2, 4, 6, 8, 10];
```

- **filter** - метод создает новый массив, в который войдут только те элементы исходного массива, для которых вызов функции callback вернет `true`. Синтаксис:
```javascript
var arr = [1, -2, 3, -4, 5];
var newArray = arr.filter(function(number) {
	return number > 0
});
console.log(newArray); // [1, 3, 5]
```

- **every** - метод возвращает `true`, если функция callback вернет `true` для каждого элемента массива, иначе метод вернет `false`. Синтаксис:
```javascript
var arr = [1, -1, 2, -2, 3];
var result = arr.every(function(number) {
  return number > 0;
});
console.log( result ); // false - не все элементы вернули true
```

- **some** - метод работает аналогично метод every, за исключением того, что вернет `true`, если в callback вернет `true` хотя бы для одного элемента массива. Синтаксис:
```javascript
var arr = [1, -1, 2, -2, 3];
var result = arr.some(function(number) {
  return number > 0;
});
console.log( result ); // true - хоть один элемент вернул true
```

- **reduce** - 

- **reduceRight** -  метод работает аналогично методу reduce, за исключением того, что идет по массиву справа-налево.

Есть несколько способов использовать функцию callback в методе массивов:

1. Определять функцию непосредственно в методе
```javascript
var arr = [1, -1, 2, -2, 3];
var result = arr.every(function(number) {
	return number > 0;
});
```

2. Определять функцию отдельно и затем передавать ее в метод
```javascript
var arr = [1, -1, 2, -2, 3];
function isPositive(number) {
	return number > 0;
};
var result = arr.every(isPositive);
```